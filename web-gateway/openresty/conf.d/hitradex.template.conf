# Load Lua module and healthcheck library
lua_package_path "/usr/local/openresty/lualib/resty/upstream/healthcheck/?.lua;;";
lua_shared_dict healthcheck 1m;
lua_socket_log_errors off;
 
upstream frontend_server {
   #ip_hash;
    hash consistent;
    ${FRONTEND_SERVERS} # Placeholder for backend servers

    # Define health check parameters
   #health_check interval=5s fails=2 passes=3;
   #check interval=5000 rise=2 fall=5 timeout=2000 type=http;
}

upstream backend_server {
   #ip_hash;
    hash consistent;
    ${BACKEND_SERVERS} # Placeholder for backend servers

    # Define health check parameters
   #health_check interval=5s fails=2 passes=3;
   #check interval=5000 rise=2 fall=5 timeout=2000 type=http;
}

#init_worker_by_lua_block {
#    local hc = require "resty.upstream.healthcheck"
#    local ok, err = hc.spawn_checker{
#        shm = "healthcheck",  -- defined by "lua_shared_dict"
#        upstream = "backend_server", -- defined by "upstream"
#        type = "http", -- support "http" and "https"
#        http_req = "GET /egw/api/ets/help/healthcheck HTTP/1.1\r\nHost: backend_server\r\nConnection: close\r\n\r\n", -- raw HTTP request for checking
#        port = nil,  -- the check port, it can be different than the original backend server port, default means the same as the original backend server
#        interval = 2000,  -- run the check cycle every 2 sec
#        timeout = 1000,   -- 1 sec is the timeout for network operations
#        fall = 3,  -- # of successive failures before turning a peer down
#        rise = 2,  -- # of successive successes before turning a peer up
#        valid_statuses = {200, 302},  -- a list valid HTTP status code
#        concurrency = 10,  -- concurrency level for test requests
#        -- ssl_verify = true, -- https type only, verify ssl certificate or not, default true
#        -- host = foo.com, -- https type only, host name in ssl handshake, default nil
#    }
#    if not ok then
#        ngx.log(ngx.ERR, "failed to spawn health checker: ", err)
#        return
#    end
#
#    -- Just call hc.spawn_checker() for more times here if you have
#    -- more upstream groups to monitor. One call for one upstream group.
#    -- They can all share the same shm zone without conflicts but they
#    -- need a bigger shm zone for obvious reasons.
#}

#init_worker_by_lua_block {
#    local hc = require "resty.upstream.healthcheck"
#
#    -- Define servers to check individually
#    local servers = {
#        { ip = "10.138.250.142", port = 8080, name = "backend_server_1" },
#        { ip = "10.138.248.141", port = 8080, name = "backend_server_2" }
#    }
#
#    for _, server in ipairs(servers) do
#        local http_req = "GET /egw/api/ets/help/healthcheck HTTP/1.0\r\nHost: " .. server.ip .. "\r\n\r\n"
#        local ok, err = hc.spawn_checker {
#            shm = "healthcheck",  -- defined by "lua_shared_dict"
#            upstream = "backend_server",  -- name of the upstream group (all servers in the group)
#            peer = server.ip .. ":" .. server.port,  -- specify server IP and port
#            type = "http",  -- protocol type for health checks
#            http_req = http_req,  -- dynamic HTTP request
#            port = server.port,  -- server port to check
#            interval = 2000,  -- check interval (ms)
#            timeout = 1000,  -- timeout for each check (ms)
#            fall = 3,  -- # of successive failures before turning a peer down
#            rise = 2,  -- # of successive successes before turning a peer up
#            valid_statuses = {200, 302},  -- valid HTTP status codes
#            concurrency = 10,  -- concurrency level for checks
#        }
#
#        if not ok then
#            ngx.log(ngx.ERR, "failed to spawn health checker for server ", server.name, ": ", err)
#            return
#        end
#    end
#}

#init_worker_by_lua_block {
#    local hc = require "resty.upstream.healthcheck"
#
#    -- Function to retrieve servers from the upstream block
#    local function get_upstream_servers(upstream_name)
#        local servers = {}
#        local u = require("ngx.upstream")
#        local peers, err = u.get_primary_peers(upstream_name)
#
#        if not peers then
#            ngx.log(ngx.ERR, "failed to get primary peers: ", err)
#            return servers
#        end
#
#        for _, peer in ipairs(peers) do
#            -- Check if peer has valid name and port
#            if peer.name and peer.port then
#                table.insert(servers, { ip = peer.name, port = peer.port })
#            else
#                ngx.log(ngx.ERR, "Peer missing name or port: ", peer.name, " ", peer.port)
#            end
#        end
#
#        return servers
#    end
#
#    -- Get servers dynamically from the "backend_server" upstream group
#    local servers = get_upstream_servers("backend_server")
#
#    -- Create health checks for each server
#    for _, server in ipairs(servers) do
#        local http_req = "GET /egw/api/ets/help/healthcheck HTTP/1.0\r\nHost: " .. server.ip .. "\r\n\r\n"
#        local ok, err = hc.spawn_checker{
#            shm = "healthcheck",
#            upstream = "backend_server",
#            peer = server.ip .. ":" .. server.port,
#            type = "http",
#            http_req = http_req,
#            port = server.port,
#            interval = 2000,
#            timeout = 1000,
#            fall = 3,
#            rise = 2,
#            valid_statuses = {200, 302},
#            concurrency = 10,
#        }
#
#        if not ok then
#            ngx.log(ngx.ERR, "failed to spawn health checker for server ", server.ip, ": ", err)
#            return
#        end
#    end
#}

init_worker_by_lua_block {
    local hc = require "resty.upstream.healthcheck"

    -- Function to retrieve servers from the upstream block
    local function get_upstream_servers(upstream_name)
        local servers = {}
        local u = require("ngx.upstream")
        local peers, err = u.get_primary_peers(upstream_name)

        if not peers then
            ngx.log(ngx.ERR, "failed to get primary peers: ", err)
            return servers
        end

        for _, peer in ipairs(peers) do
            -- Check if peer has valid name and port
            if peer.name then
                table.insert(servers, { name = peer.name })
            else
                ngx.log(ngx.ERR, "Peer missing name or port: ", peer.name, ";")
            end
        end

        return servers
    end

    -- Get servers dynamically from the "backend_server" upstream group
    local servers = get_upstream_servers("backend_server")

    -- Create health checks for each server
    for _, server in ipairs(servers) do
        local http_req = "GET /egw/api/ets/help/healthcheck HTTP/1.0\r\nHost: " .. server.name .. "\r\n\r\n"
        local ok, err = hc.spawn_checker{
            shm = "healthcheck",
            upstream = "backend_server",
            peer = server.name,
            type = "http",
            http_req = http_req,
            port = server.port,
            interval = 2000,
            timeout = 1000,
            fall = 3,
            rise = 2,
            valid_statuses = {200, 302},
            concurrency = 10,
        }

        if not ok then
            ngx.log(ngx.ERR, "failed to spawn health checker for server ", server.ip, ": ", err)
            return
        end
    end
}


server {
    listen 80;
    server_name ${SERVER_NAMES};
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl;
    server_name ${SERVER_NAMES};
    keepalive_timeout 70;

    access_log  /var/log/nginx/hitradex-access.log  main;

    # SSL Certificate and Key
    ssl_certificate cert/${FILE_CERT_CRT};
    ssl_certificate_key cert/${FILE_CERT_KEY};

    # SSL Configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'EECDH+AESGCM:EECDH+CHACHA20:EDH+AESGCM:AES256+EECDH:AES256+EDH';
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 5m;
    ssl_session_tickets off;  # Disabling session tickets enhances forward secrecy
    
    # Enable OCSP Stapling for better SSL handshake performance
    #ssl_stapling on;
    #ssl_stapling_verify on;
    #resolver 8.8.8.8 8.8.4.4 valid=300s;
    #resolver_timeout 5s;
    
    # HSTS (HTTP Strict Transport Security)
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    # Additional Security Headers
    #add_header X-Frame-Options SAMEORIGIN;
    #add_header X-Content-Type-Options nosniff;
    #add_header Referrer-Policy no-referrer-when-downgrade;
    #add_header Content-Security-Policy "default-src 'self';";

    set $backend_scheme ${BACKEND_SCHEME};
    set $frontend_scheme ${FRONTEND_SCHEME};

    location /egw/ {
        proxy_pass $backend_scheme://backend_server$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_redirect off;
    }

    location /egw/ws/ {
        proxy_pass $backend_scheme://backend_server$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_redirect off;
    }

    location /tv/ {
        proxy_pass $backend_scheme://backend_server$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_redirect off;
    }

    location /tradingview/ {
        proxy_pass $backend_scheme://backend_server$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_redirect off;
    }

    location /newsserver/ {
        proxy_pass $backend_scheme://backend_server$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_redirect off;
        charset iso-8859-11;
    }

    location / {
        proxy_pass $frontend_scheme://frontend_server;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_redirect off;
    }
}


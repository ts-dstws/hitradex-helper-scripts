# Load Lua module and healthcheck library
lua_package_path "/usr/local/openresty/lualib/resty/upstream/healthcheck/?.lua;;";
lua_shared_dict healthcheck 1m;
lua_socket_log_errors off;
 
upstream frontend_server {
   #ip_hash;
    hash consistent;
    ${FRONTEND_SERVERS} # Placeholder for backend servers

    # Define health check parameters
   #health_check interval=5s fails=2 passes=3;
   #check interval=5000 rise=2 fall=5 timeout=2000 type=http;
}

upstream backend_server {
   #ip_hash;
    hash consistent;
    ${BACKEND_SERVERS} # Placeholder for backend servers

    # Define health check parameters
   #health_check interval=5s fails=2 passes=3;
   #check interval=5000 rise=2 fall=5 timeout=2000 type=http;
}

#init_worker_by_lua_block {
#    local hc = require "resty.upstream.healthcheck"
#
#    -- Function to retrieve servers from the upstream block
#    local function get_upstream_servers(upstream_name)
#        local servers = {}
#        local u = require("ngx.upstream")
#        local peers, err = u.get_primary_peers(upstream_name)
#
#        if not peers then
#            ngx.log(ngx.ERR, "failed to get primary peers: ", err)
#            return servers
#        end
#
#        for _, peer in ipairs(peers) do
#            -- Check if peer has valid name and port
#            if peer.name and peer.port then
#                table.insert(servers, { ip = peer.name, port = peer.port })
#            else
#                ngx.log(ngx.ERR, "Peer missing name or port: ", peer.name, " ", peer.port)
#            end
#        end
#
#        return servers
#    end
#
#    -- Get servers dynamically from the "backend_server" upstream group
#    local servers = get_upstream_servers("backend_server")
#
#    -- Create health checks for each server
#    for _, server in ipairs(servers) do
#        local http_req = "GET /egw/api/ets/help/healthcheck HTTP/1.0\r\nHost: " .. server.ip .. "\r\n\r\n"
#        local ok, err = hc.spawn_checker{
#            shm = "healthcheck",
#            upstream = "backend_server",
#            peer = server.ip .. ":" .. server.port,
#            type = "http",
#            http_req = http_req,
#            port = server.port,
#            interval = 2000,
#            timeout = 1000,
#            fall = 3,
#            rise = 2,
#            valid_statuses = {200, 302},
#            concurrency = 10,
#        }
#
#        if not ok then
#            ngx.log(ngx.ERR, "failed to spawn health checker for server ", server.ip, ": ", err)
#            return
#        end
#    end
#}

init_worker_by_lua_block {
    local hc = require "resty.upstream.healthcheck"

    -- Function to retrieve servers from the upstream block
    local function get_upstream_servers(upstream_name)
        local servers = {}
        local u = require("ngx.upstream")
        local peers, err = u.get_primary_peers(upstream_name)

        if not peers then
            ngx.log(ngx.ERR, "failed to get primary peers: ", err)
            return servers
        end

        for _, peer in ipairs(peers) do
            -- Check if peer has valid name and port
            if peer.name then
                table.insert(servers, { name = peer.name })
            else
                ngx.log(ngx.ERR, "Peer missing name or port: ", peer.name, ";")
            end
        end

        return servers
    end

    -- Get servers dynamically from the "backend_server" upstream group
    local servers = get_upstream_servers("backend_server")

    -- Create health checks for each server
    for _, server in ipairs(servers) do
        local http_req = "GET /egw/api/ets/help/healthcheck HTTP/1.0\r\nHost: " .. server.name .. "\r\n\r\n"
        local ok, err = hc.spawn_checker{
            shm = "healthcheck",
            upstream = "backend_server",
            peer = server.name,
            type = "http",
            http_req = http_req,
            port = server.port,
            interval = 2000,
            timeout = 1000,
            fall = 5,
            rise = 2,
            valid_statuses = {200, 302},
            concurrency = 10,
        }

        if not ok then
            ngx.log(ngx.ERR, "failed to spawn health checker for server ", server.ip, ": ", err)
            return
        end
    end
}


server {
    listen 80;
    server_name ${SERVER_NAMES};
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl;
    server_name ${SERVER_NAMES};
    keepalive_timeout 70;

    access_log  /var/log/nginx/hitradex-access.log  main;

    # SSL Certificate and Key
    ssl_certificate cert/${FILE_CERT_CRT};
    ssl_certificate_key cert/${FILE_CERT_KEY};

    # SSL Configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'EECDH+AESGCM:EECDH+CHACHA20:EDH+AESGCM:AES256+EECDH:AES256+EDH';
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 5m;
    ssl_session_tickets off;  # Disabling session tickets enhances forward secrecy
    
    # Enable OCSP Stapling for better SSL handshake performance
    #ssl_stapling on;
    #ssl_stapling_verify on;
    #resolver 8.8.8.8 8.8.4.4 valid=300s;
    #resolver_timeout 5s;
    
    # HSTS (HTTP Strict Transport Security)
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    # Additional Security Headers
    #add_header X-Frame-Options SAMEORIGIN;
    #add_header X-Content-Type-Options nosniff;
    #add_header Referrer-Policy no-referrer-when-downgrade;
    #add_header Content-Security-Policy "default-src 'self';";

    set $backend_scheme ${BACKEND_SCHEME};
    set $frontend_scheme ${FRONTEND_SCHEME};

    location /egw/ {
        proxy_pass $backend_scheme://backend_server$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_redirect off;
    }

    location /egw/ws/ {
        proxy_pass $backend_scheme://backend_server$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_redirect off;
    }

    location /tv/ {
        proxy_pass $backend_scheme://backend_server$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_redirect off;
    }

    location /tradingview/ {
        proxy_pass $backend_scheme://backend_server$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_redirect off;
    }

    location /newsserver/ {
        proxy_pass $backend_scheme://backend_server$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_redirect off;
        charset iso-8859-11;
    }

    location / {
        proxy_pass $frontend_scheme://frontend_server;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-Port $server_port;
        proxy_set_header X-Real-Scheme $scheme;
        proxy_redirect off;
    }
}

